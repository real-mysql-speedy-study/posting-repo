# MySQL 엔진과 스토리지 엔진
MySQL 서버는 MySQL 엔진(머리)과 스토리지 엔진(손,발) 으로 구성된다. 

MySQL 엔진은 SQL 문장을 분석하거나 최적화하는 역할을 한다.
예시를 들자면 이런 것들이 있다. 
- 클라이언트의 접속과 쿼리 요청을 처리
- SQL 전처리 및 파싱
- 쿼리를 최적화시켜 실행하는 옵티마이징

스토리지 엔진은 앞에 MySQL엔진에서 처리하는 실제 데이터를 디스크에 저장하거나 읽어오는 역할을 한다.
스토리지 엔진은 필요에 따라 한 MySQL엔진에 여러개를 동시에 등록할 수 있다. 등록 방법은 create문 뒤에 `ENGINE=엔진이름`을 붙여주면 된다. 이 스토리지 엔진은  INNODB랑 MYISAM이 대표적인데 이외에도읽기 쓰기 요청(핸들러 요청)을 처리하는 API인 `핸들러 API`를 만족하게 구현하면 직접 커스텀구현한 엔진도 사용할 수 있다. 

# MySQL 엔진 아키텍처
## MySQL 스레딩 구조
MySQL은 스레드기반으로 작동한다. 크게 3개의 포그라운드 스레드와 41개의 백그라운드 스레드로 구분된다.

### 포그라운드 스레드
포그라운드 스레드는 클라이언트 스레드라는 이름으로도 불리며, 이름 그대로 MySQL에 접속해있는 클라 수만큼 존재한다. 
주로 각각의 클라이언트가 요청하는 쿼리 문장을 처리하고, 처리할 데이터를 데이터 버퍼나 캐시에서 가져오는 역할을 한다.
만약 데이터버퍼나 캐시에 없으면 디스크나 인덱스파일을 뒤져서 데이터를 찾아온다. 쓰기작업이 있을때는 엔진별로 다른데 MyISAM은 디스크쓰기까지, INNODB는 데이터 버퍼나 캐시에서 찾아오는 것까지만 하고 버퍼에 있는걸 디스크에 기록하는건 백그라운드가 맡게끔 구현되어있다. 

작업을 마치고 커넥션이 종료되면 이 스레드는 스레드 캐시로 이동한다.
이때 스레드를 마냥 유지하는것도 비용이라 캐시에 이미 일정 개수 이상의 스레드가 차있다면, 새로 캐시에 들어오려는 스레드는 종료시킨다. 이로써 서버 리소스를 마냥 잡아먹지 않게끔 관리할 수 있다. 스레드풀이랑 뭔차인가 싶은데 만약 스레드 캐시에 있는 스레드가 0개면 대기하는게 아니라 새로운 스레드를 만들어서 데이터를 처리한다는 점이 스레드풀과 약간 다르다.

### 백그라운드 스레드 
MYISAM은 딱히 없지만 INNODB는 백그라운드가 많은 일을 처리한다. 대충 적자면 다음과 같다.
- Insert buffer에 있는 내용을 병합
- 로그를 디스크로 기록
- 버퍼풀의 데이터를 디스크에 기록
- 데이터를 버퍼로 불러오기
- 잠금이나 데드락 모니터링
.
.
.

음..아무튼 겁나 많다. 이중에서 쓰기스레드가 중점적으로 볼만한 부분인데 DBMS 특성상 읽기는 클라이언트 스레드에서 처리되지만, 쓰기는 백그라운드스레드에서 처리하기때문에 보통 내장 디스크를 사용한다면 2~4개정도 잡아주는게 좋다. 보통 DBMS는 쓰기는 좀 지연돼도 되지만 읽기는 지연되면 안되기 때문에 데이터가 추가 및 변경될경우 디스크에 쓰는걸 기다리지 않고도 읽을 수 있게끔 구현되어있다. 근데 앞서 말한것처럼 MyISAM은 사용자 스레드가 쓰기까지 다 처리해서... 변경 있을때 쓰기를 지연시킬수가 없다. 근데 쓰기할때 테이블단위의 잠금(update 및 delete할 때)이 있으니... MyISAM쓰는데 쓰기처리 많으면 좀 느리겠다 싶다.

## 메모리 구조
### 글로벌 메모리
운영체제로부터 할당받은 MySQL서버의 메모리이다. 클라이언트 스레드 수와 상관없이 할당받는 공간이며 클라이언트 스레드 전체가 공유된다. 
대표적으로는 
- 테이블 캐시
- InnoDB 버퍼풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두로그 버퍼

가 있다.

### 로컬 메모리(세션 메모리)
클라이언트 스레드가 쿼리를 처리할 때 사용하는 메모리 영역이다. 한 클라이언트가 단독으로 사용하는 공간이다. 
커넥션 단위로 할당되며 이 커넥션을 MYSQL서버 내에서는 세션이라고도 해서 세션 메모리라는 이름으로 불리기도 한다.

대표적으로는
- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼(커넥션 버퍼)

가 있는데 위에 소트나 조인은 이름으로 때려 맞출 수 있듯이 쿼리문 실행할때 필요한 공간이라 이 쿼리문이 아니면 할당도 안되는 공간이다.
쿼리문이 있더라도 이거 실행하고 나면 바로 해제된다.  반면 밑에 두개는 커넥션 내내 유지되고 커넥션 끊어질때 해제된다. 사실 스프링에서 커넥션풀 크기 적당히 지정해서 사용한다면 OOM 날 일이 없을 듯 싶긴한데... 만약 풀이 아니라 커넥션 그때그때 만드는 정책을 쓰고있거나 내 MySQL이 올라가있는 인스턴스가 너무 구려서 [MYSQL 기본 메모리 설정값](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html)을  못따라갈것같으면 각 버퍼별로 사이즈 지정을 직접 해주면 된다. (근데 사실 거의 메모리 초과떠서 뻑나는 경우는 희박하다고 한다. 그래도.. 만약을 위한다면야)


## 쿼리 실행 구조
MySQL은 쿼리를 실행할때 다음과 같은 과정을 거친다. 
![](https://velog.velcdn.com/images/harukawa99/post/db7cc0d6-9bf0-4f38-8b08-d10f4f878b81/image.png)

하나씩 뜯어보자
### 쿼리 파서
요청으로 들어온 문장을 MySQL이 인식할 수 있는 언어인 토큰으로 바꾸어 줍니다. (문장을 번역하는거다보니 문법에러까지 잡습니다) 쿼리파서는 이 토큰을 트리 구조로 만든 [파서 트리](https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%8A%A4_%ED%8A%B8%EB%A6%AC) 생성 작업까지를 담당한다. 참고로 파서트리는 문법을 표현하기에 적합한 트리라는데 자세한 내용은 위키 참고하자. 

### 전처리기
파서 트리를 기반으로 쿼리문장에 있는 테이블 이름이나 컬럼명 내장함수같은 개체를 매핑해서 객체의 존재여부나 접근 권한등을 확인한다. 실제로 이 쿼리가 진짜 돌아갈 수 있는지 검증하는 역할 정도로 보면 될듯하다.

### 옵티마이저
만들어진 쿼리문장을 어떻게 해야 저렴하게 처리하나 고민하는 역할이다. 사실상 앵간한 동작을 결정하는앤데 어떻게 해야 더 저렴한 방법으로 유도할지는 개발자 역량이다. 아마 책 뒤쪽에 자세히 나올듯.

### 실행 엔진
실행 엔진은 옵티마이저가 만든 계획대로 핸들러에게 요청해서 받은 결과를 다시 다른 핸들러한테 입력해주는 일종의 중간관리자 정도 되는 애다. 좀더 자세한 방법을 적어보자면 다음과 같다.

1. 실행엔진이 핸들러한테 임시테이블 만들라고 요청
2. 실행엔진은 where 절에 일치하는 레코드 읽어오라고 핸들러한테 요청
3. 읽어온 레코드들을 임시테이블에 저장하라고 핸들러한테 요청
4. 임시테이블에 저장된 데이터를 필요에 맞춰서 읽으라고 핸들러한테 요청
5. 최종 결과물을 사용자나 다음 모듈로 넘김.

보면은 걍 핸들러한테 요청 쏘고쏘고 해서 나온 결과물 반환하는 정도의 역할이다. 

### 핸들러(스토리지 엔진)
핸들러는 MySQL 가장 밑에서 실행엔진의 요청이 들어오는대로 디스크를 읽거나 쓰는 역할을 한다. 위에서 MySQL의 손과 발로 비유했던 스토리지엔진과 동일한 의미이다. 

## 쿼리 캐시
쿼리캐시는 웹 기반의 응용 프로그램에서 빠른 응답을 처리하기 위한 것이다. SQL 실행결과를 메모리에 캐시하고 동일한 구문이 실행되면 메모리에서 쓱싹 가져오기때문에 테이블 조회가 따로 필요하지 않다. 말만 들으면 좋은데 캐시의 근본적인 이슈 중 하나가... 이거 테이블 데이터 바뀌면 다 삭제해줘야하는데 이거 처리하는게 비용이 비싸다. 그리고 은근 잘 안쓰인다고 한다. 그래서 8.0 올라오면서는 없앴다. 힝구..


## 스레드 풀
MySQL내에서는 스레드풀을 잡아서 쿼리를 실행하는 스레드의 갯수를 제한함으로써 서버의 자원소모를 줄일 수 있다. 왜 좋은지는 스레드풀 자체의 원리나 이점을 알아보면 된다. 나는 전에 톰캣 스레드풀 잡는거 하다가 공부했어서 이거 설명은 넘어갈란다. 무료버전에는 플러그인으로 깔아야하고 유료버전에는 그냥 기본으로 들어가있다. ~~돈이좋다~~ 플러그인을 쓰면 선순위큐나 후순위큐를 활용해서 특정 트랜잭션이나 쿼리를 우선으로 처리할 수 있다고 한다. 이거 쓰면 사용자 요청이 유입된 순서와 다르게 재배치해서 일찍 들어온 트랜잭션 내의 SQL을 먼저 처리하게 함으로써 잠금을 더 빨리 해제하고 경합도 덜 시킬 수 있다. 

## 트랜잭션 지원 메타 데이터
데이터베이스 서버내의 테이블 구조나 내부 프로그램 정보를 데이터 딕셔너리(메타데이터) 라고 한다. 5.7까지는 이런 메타데이터를 FRM 파일에 저장했는데 파일 기반으로 저장하다보니 생성이나 변경작업에 트랜잭션이 지원되지 않아서 비정상적으로 종료될 경우 롤백도 안되고 그냥 테이블 뻑난 그대로 기록된다. 이걸로 복구하려하면 애 좀 먹을 텐데.. 싶어서 8.0부터는 innoDB내의 테이블에 저장하게끔 개선했다. MySQL 서버가 작동할때 기본으로 필요한 정보(대체로 인증, 권한..)를 저장하는 테이블을 시스템테이블이라고 하는데 이거랑 메타데이터를 InnoDB내에 저장하게 개선함으로써 트랜잭션 개념을 도입할 수 있어졌다. 이로써 비정상적으로 종료됐을때 스키마 변경이 완전 성공 혹은 완전 실패 둘중하나로 결론나서 테이블이 깨지지 않게 됐다. 스토리지 엔진에 따라 저장방식이 다른데 SDI라는 파일에 저장한다는것만 알고 넘어가도 될 것 같다. 
