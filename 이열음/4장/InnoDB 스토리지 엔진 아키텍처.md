# InnoDB 스토리지 엔진 아키텍처

## 프라이머리 키에 의한 클러스터링
InnoDB는 기본적으로 프라이머리 키를 클러스터링 인덱스로 지정해서 저장한다. PK순으로 저장되며 세컨더리는 PK를 논리적인 주소로 사용한다. PK가 클러스터링 인덱스로 지정되다보니 레인지 스캔이 빠르다. MyISAM에서는 클러스터링 인덱스를 지원하지 않아서 프라이머리키는 걍 유니크 걸린 세컨더리키랑 같다. 

## 외래키 지원
InnoDB에서는 외래키를 지원한다. 외래키가 잡혀있으면 관계파악하기 좋아서 개발환경에서는 종종 쓴다고 한다. 부모테이블과 자식테이블간의 관계가 왕끈끈하게 엮여있어서 변경할때 체크하느라 잠금이 여러군데 걸리기 때문에 데드락 위험성이 크니 유의하자. 가끔 짜증나면 외래키 체크 꺼버려도 되는데 이러면 정합성 깨지기 쉬우니 잘 체크해야한다.

## MVCC
하나의 데이터에 대해서 버전을 여러개 두고 관리한다는 의미이다. 레코드레벨의 락과 트랜잭션을 지원하기 위해 DBMS가 제공하는 기능이며 격리수준에 따라 서로 다른 버전을 보여준다. 이건 뒤에 격리레벨 다룰때 자세히 다루겠다. 이 MVCC는 격리수준이 Serializable이 아니고, 쓰기 요청이랑 안엮여있는 경우엔 다른 트랜잭션과 관계없이 읽을 수 있게 해준다. DB에서 다른 트랜잭션에 의해 내가 읽고자 하는 데이터가 변경됐어도 커밋하지 않았다면 커밋까지 기다리는게 아니라 내가 요청한 시점의 데이터를 바로 읽을 수 있게끔 해주는 것이다. 

## 자동 데드락 감지
잠금이 서로 물리고 물려서 교착상태가 발생할 수 있는데 innoDB는 이를 빨리 풀어주기 위해서 잠금 목록을 그래프로 관리한다. 그리고 데드락 감지용 스레드가 그 그래프를 검사해서 서로 데드락걸려있으면 하나 강제종료해준다. 강제종료의 기준은 언두로그의 양인데, 취소했을때 언두해야할 내용이 적을수록 비용측면에선 이득이기 때문에 언두로그 작은걸 강제종료 시킨다. 근데 동시처리 스레드가 겁나 많거나 트랜잭션 잠금이 많아질수록 감지가 느려진다. 검사하는동안 관계도가 변하지 않게끔 잠금 그래프에도 락을 걸고 검사하게 되기 때문이다. 이러다보면 처리스레드는 데드락 검사 끝날때까지 기다려야해서 성능이 구려지는 경우가 있는데 이럴땐 데드락 스레드 끄고 락 타임아웃을 50초보다 낮게 줌으로서 해결할 수 있다.


## 자동 장애 복구
손실이나 장애에 대응하기 위해 자동으로 복구작업이 진행되는데, 보통의 경우에는 잘 복구되지만 하드웨어 이슈에는 답이없다. 복구할때 쓰는 데이터파일이 깨져있다면 자동복구를 멈추고 MySQL을 종료시키는데 이때는 복구용 시스템 변수를 지정해서 강제로 복구하게 해야한다. 

## InnoDB 버퍼풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시하는 공간이다. 쓰기 작업을 지연시켜놓고 일괄로 처리할 수 있게끔 하는 역할도 같이한다. 쓰기작업에 연관된 레코드는 보통 여기저기 분산되어있어서 디스크에 랜덤으로 접근해야하는데 얘는 메모리라 랜덤접근시 시간을 줄이고 빠르게 쓸 수 있다. 더불어 메모리에 있는 데이터는 쓰기를 지연시켰다가 나중에 디스크에 동기화시키기 때문에 데이터베이스 자체의 성능도 올릴 수 있다. 

메모리인 만큼 풀의 크기를 지정해줘야하는데 적정 메모리 크기는 대체로 물리메모리의 80%이다. 하지만 클라이언트 스레드나 운영체제 같이 다른 애들도 메모리를 쓰긴 써야해서 냅다 갖다 꽂기보단 50%로 잡아놓고 상황에 따라 유동적으로 조절하는게 좋은 방식이라고 한다. 

### 버퍼풀 구조
버퍼풀은 메모리 공간을 페이지 크기단위로 조각내어두고 필요한 데이터가 들어있는 데이터 페이지를 읽어서 조각에 저장한다. 이 크기를 관리하기 위해선 LRU 리스트, 플러시 리스트, 프리 리스트 세가지를 관리해야한다. 

- LRU 리스트

디스크로부터 한번 읽어온 페이지를 최대한 오래 유지해서 디스크 읽기를 최소화 하기 위한 리스트이다. 처음 읽힌 데이터는 LRU 헤더에 꽂히고 한번 읽힌 데이터페이지가 자주 사용된다 싶으면 MRU 영역(new 영역) 맨위 로 승급된다. 잘 안읽히는 애들은 밀리고 밀려서 LRU(old영역) 끝까지 가면 버퍼풀에서 제거되는 방식이다. 상주하는 데이터 페이지마다 나이가 부여되어서 나이가 너무 오래되면 버퍼풀에서 제거한다.

- 플러시 리스트

디스크로 동기화되지 않은 데이터를 가진 데이터 페이지를 변경 시점의 페이지 목록을 관리한다. 디스크에서 읽어온 상태에서 변경이 일어나면 디스크에 기록하기 위해서 데이터 페이지에 변경내용을 반영하고 이를 플러시 리스트로 올려서 관리한다. 

- 프리 리스트

InnoDB 버퍼풀에서 사용자 데이터로 채워지지 않은, 즉 비어있는 페이지들의 리스트이다. 새롭게 디스크의 데이터를 읽어올때 사용한다. 

### 리두로그
버퍼풀의 크기, 즉 버퍼풀이 가지는 메모리 공간을 늘리면 디스크 내의 데이터를 많이 적재시켜서 성능을 올리는 `캐시` 기능이 향상된다. 근데 InnoDB 버퍼풀에는 캐시 말고도 `쓰기 버퍼링`이라는 기능을 통해 데이터베이스의 성능을 향상시킨다. 그럼 이 쓰기 버퍼링을 쓰려면 어떻게 해야하냐. 리두로그를 사용하면 된다. 

리두로그가 뭐냐면.. 일종의 변경 기록지다. 버퍼풀은 디스크에서 읽어온 데이터를 버퍼풀에 넣어놓고 변경이 없는 데이터를 기록해두는 `클린페이지`와 변경사항을 저장하는 `더티페이지`를 가진다.  이때 더티 페이지는 언젠가 디스크에 기록되어야하는데 디스크에 기록하기전에 데이터베이스에 장애가 발생하게 되면 변경내용을 복구해야하기 때문에 로그로 변경을 기록해둔다. 이걸 리두로그라고 한다. 

이 리두로그는 맨 마지막에 데이터가 쓰이면 다시 맨앞으로 돌아가서 덮어쓰기하는 순환 고리 파일이다. 이때 재사용할 수 없는 공간을 `활성 리두 로그`라고 한다. 리두로그에 한줄씩 추가할때마다 로그 포지션을 증가시키면서(LSN) 기록하는데, InnoDB는 주기적으로 리두로그와 버퍼풀의 더티페이지를 디스크에 쓰면서 활성리두로그의 시작점을 체크포인트의 LSN으로 변경해줌으로서 사용가능한 영역과 사용불가능한 영역을 구분해준다. 그리고 이 체크포인트 LSN부터 마지막 리두로그의 LSN까지, 즉 디스크에 동기화되지 않은 로그 시작점 ~ 가장 마지막에 쓰인 로그까지의 차이를 `체크포인트 에이지`라고 한다. 

아무튼 이 리두로그도 크기설정을 잘 해주는게 관건인데 적절히 버퍼링 걸리면서도 디스크 쓰기 시점에 부하가 너어어어무 크진 않게 해주는게 좋다. 대충 5~10G 사이로 해놓고 늘려가면서 최적값을 찾자.


### 버퍼 풀 플러시
버전 6까지는 디스크에 냅다 쓰다보니 쿼리처리가 일시적으로 느려지기도 했었다. 7과 8을 거치면서 이게 좀 매끄럽게 처리되기 시작했는데 어떻게 한건지 알아보자.

InnoDB 스토리지 엔진은 이를 위해 총 두가지의 플러시를 백그라운드에서 실행한다. 

- 플러시 리스트 플러시
	리두로그 엔트리가 사용하는 공간을 비우기 위해서 디스크에 더티페이지를 동기화 시킨다. 이때 오래 전에 발생한 변경부터 동기화시키는 클리너 스레드를 실행시키기 위해 주기적으로 `플러시 리스트 플러시 함수`를 호출한다. 이때 너무 많은 쓰기가 한번에 발생하는걸 방지하기 위해서 innodb_max_dirty_pages_pct_lwm 이라는 환경변수를 통해 더티페이지가 몇퍼센트 찼을때 플러시 시킬건지 지정한다.
- LRU 리스트 플러시
사용 빈도가 낮은 데이터페이지를 제거하고 새로 읽어올 공간을 만들기 위해 사용한다. 지정된 갯수만큼 페이지를 스캔하면서 디스크에 동기화 시키고 클린페이지를 프리리스트로 옮겨주는 역할을 한다. 

### 버퍼풀 복구 
서버 껐다가 켜면 처음에 처음 요청에 대한 데이터는 쿼리성능이 구리다. 버퍼풀에 적재가 안되어있어서 그런건데 이런 상황을 방지하기 위해서 서비스 시작전에 미리 켜놓고 데이터를 적재시키는 웜업을 거쳤었다. 하지만 6버전 부터는 환경변수 설정해놓으면 종료시점의 버퍼풀을 덤프 떠놓고 시작할때 상태를 복구할 수 있게 됐다. 환경변수를 설정해놓으면 자동화도 된다고 한다. 기본적으로 LRU 리스트에 적재된 데이터의 메타정보만 가져와서 저장하기 때문에 풀 백업은 빠른데 진짜 데이터 내용 자체를 복구하는건 디스크 왔다갔다하면서  풀 크기가 크면 너무 오래 걸릴수도 있다. 너무 오래걸린다 싶으면 적당히 하고 꺼주자. 

## Double write buffer
Double write buffer는 데이터를 안정적으로 디스크에 동기화하기 위해서 제공하는 기능이다. 리두로그는 페이지의 변경된 내용만 기록한다. 때문에 디스크 동기화 중 예상치 못하게 종료되면 쓰고있던 더티페이지의 다음 내용은 복구가 안될수도 있다. 이걸 `파셜페이지` 혹은 `톤페이지`라고 한다. 이를 방지하기 위해서 InnoDB는 Double-write 기법을 사용한다. 플러시 하기 전에 일정 범위의 데이터를 묶어서 시스템 테이블 스페이스에 있는 double write 버퍼에 기록해둔다. 그 다음에 하나씩 랜덤으로 디스크에 작성하고 정상 기록됐다고 판단하면 그땐 비워준다. 만약 비정상 종료됐을 경우에는 데이터 파일의 페이지와 버퍼내의 데이터를 비교해서 다른게 있으면 버퍼의 데이터를 데이터파일에 복사해준다. 

버퍼에 기록할때는 순차 IO가 발생하는데, SSD처럼 랜덤이나 순차나 성능이 비슷하면 부담으로 느껴질 수도 있긴 하다. 그래도 정합성이 정 중요하면 활성화해주자. 리두로그가 동기화 안되게 설정해줬으면 끄는게 낫다고한다.

## 언두로그
DML 이전 버전의 데이터는 별도로 백업하는데 이런 백업데이터를 언두로그라고 한다. 트랜잭션이 뻑나면 언두로그를 통해 이전데이터로 복구하기도 하고, 격리수준에 따라 보이는 데이터를 달리해주기 위해서 사용하기도 한다. 트랜잭션 여러개가 한 데이터를 수정한다 하면 한 언두로그에 그 수정내용이 전부 로그형태로 기록되고 마지막 트랜잭션이 완료될때 언두로그 내용이 반영된다. 그러다보니 트랜잭션이 너어어어무 안끝나고 + 변경내용이 많으면 언두로그 이력 스캔때문에 쿼리 성능이 떨어지기도 한다. 버전 6까지는 크기이슈가 있었는데 7과 8에서는 순차 사용이나 자동 크기 조절을 통해서 크기에 대한 이슈를 해결했다. 

### 언두 테이블 스페이스 관리
언두로그를 저장하는 공간을 언두 테이블스페이스라고 한다. 6버전 이전에는 시스템 테이블스페이스에 언두로그를 저장했지만 이후에는 언두로그 파일에 저장하는 방식으로 바꿨다. 내부에는 1개에서 128개 사이의 롤백 세그먼트가 있고 그 안에는 페이지 크기를 16바이트로 나눈 값의 개수만큼 언두슬롯이 있다. 

언두로그 슬롯이 부족하면 트랜잭션을 실행할 수 없기 때문에 한 트랜잭션당 2개의 언두슬롯을 사용한다 가정하고 동시에 돌릴 수 있는 트랜잭션 갯수를 가늠하여 롤백 세그먼트 개수를 정해주자. 근데 대체로 일반적인 상황에는 디폴트값이면 된다고 한다. 버전 8 이후부터는 언두 테이블 스페이스를 동적으로 추가 삭제할 수 있는 기능도 추가되었다. 이를 통해 불필요한 공간을 운영체제로 반납하는 `undo tablespace truncate`를 할 수 있게 됐다.


## 체인지 버퍼
데이터가 변경되었을때 인덱스를 업데이트 해줘야하는데 인덱스 업데이트는 디스크에 랜덤하게 접근하므로 많은 자원을 소모한다. 그래서 InnoDB에서 버퍼풀에 없는 데이터의 인덱스를 업데이트 할때는 임시 공간에 저장해두고 사용자에게 바로 결과를 반환하는데 이때 임시공간을 체인지 버퍼라고 한다.(유니크 인덱스에는 사용할 수 없다.) 여기 있는 내용은 이후 버퍼 머지 스레드가 디스크에 반영해준다.

## 리두로그 및 로그버퍼, 아카이빙
리두로그는 데이터의 일관성을 보장하는 Durable과 직결된 기능이다. 데이터베이스 서버는 데이터를 변경하기 전에 변경내용을 일단 로그로 먼저 기록한다. 이를 통해 비정상 종료시의 복구를 진행할 수 있게 된다.

비정상 종료됐을때 데이터 일관성이 깨지는 케이스는 다음 두가지가 있다.
- 커밋됐지만 데이터 파일에 기록되지 않은 데이터
- 롤백됐지만 데이터 파일에 이미 기록된 데이터

1번은 리두로그에 저장된 데이터를 데이터 파일에 복사해주지만 
2번은 언두로그의 내용을 가져와서 데이터 파일에 복사해준다. 

8.0부터는 리두로그 아카이빙 기능까지 추가되어 안정성을 더욱 높였다.
이에 더해 리두로그를 비활성화 시켜서 대용량 데이터의 적재시간을 단축시킬 수도 있게 됐는데 적재 다되면 복구를 위해 다시 활성화시켜주자. 

## 어댑티브 해시 인덱스
어댑티브 해시 인덱스는 InnoDB 버퍼풀 내에서 사용자가 자주 부른다 싶은 데이터에 자동으로 거는 인덱스다. 해시 구조라서 일반 인덱스 구조인 B-Tree에 비해 검색시간이 짧고 검색 비용도 싸다. 루트부터 검색하는 방식이 아니라 걍 해시값을 바로 찾는 방식이라 세마포어 횟수도 많이 줄어든다. 주로 다음과 같은 상황에 성능향상이 빛을 본다고 한다.

- 디스크 읽기가 많지 않은 경우
- 동등 조건 검색이 많은 경우
- 쿼리가 일부 데이터에 집중되어있는 경우

반대로 이럴때는 사용해도 별로 성능향상이 없다.

- 디스크 읽기가 많은 경우
- 특정 패턴 쿼리가 많은 경우
- 큰 데이터를 넓게 읽는 경우

버퍼풀 내에 한정되는 성능 향상이므로 디스크 읽기가 많으면 아무 소용이 없다. 
그리고 삭제나 변경이 발생했을때도 어댑티브 해시인덱스에서 그 데이터들을 다 지워줘야해서 데이터베이스 서버 처리 성능이 느려진다. 따라서 항상 능사는 아니고 MySQL 상태 값을 살펴보면서 메모리 사용량을 조절해주자. 

# InnoDB와 MyISAM, MEMORY 비교
MyISAM은 위에서 얘기한 것처럼 지원하는 기능들이 좀 없고 테이블단위 락걸어서 성능도 구려가지고 이제 거의 안쓰고 InnoDB가 디폴트가 되었다. 키캐시도 그닥 성능이 막 낫지도 않다고 하니까 머... Memory는 동시처리 성능에 있어서 테이블 단위 락을 거니까 성능이 InnoDB보다 구리다. 

# 로그 
내부를 몰라도 로그를 보면 적당히 파악할 수 있는 에러들도 있는데 이정도는 로그로 보여준다. 

## 에러로그
- MySQL 시작과정과 정보성 에러메세지
- InnoDB 트랜잭션 복구 메세지
- 쿼리 처리 도중 난 에러 메세지
- 비정상적으로 종료된 커넥션 메세지(클라 정상 종료 불가)
- InnoDB 상태 조회 결과 메세지
- MYSQL 종료 메세지 

## 제너럴 쿼리 로그
실행되는 쿼리 뭐있는지 전체목록 조회해볼 수 있다. 에러발생한 쿼리도 같이 기록된다. 
## 슬로우 쿼리 로그 
튜닝할때 어떤 쿼리에서 성능저하 나는지 판단할때 쓰는 로그이다. 빈도나 처리 시간순으로 정렬해서 쿼리를 보고 어떤 쿼리를 튜닝할지 정하면 된다. 
