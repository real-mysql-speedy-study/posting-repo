# 트랜잭션
작업의 완전성을 보장한다. 작업을 셋으로 묶어서 완전하게 처리하거나 처리하지 못한 경우 두가지로 나눠서 후자의 경우 원상태로 복구한다. 이러면 작업이 진행되다가 말아서 데이터가 깨지는 일을 방지할 수 있다.(데이터 정합성 보장)


# 트랜잭션이 왜 필요한가?
일단 데이터가 일부만 업데이트되면 왜 복구되어야하는지에 대한 이해가 우선적으로 필요하다. 닥터마틴 워커를 사는 상황을 가정해보자.

- 사용자가 닥마를 결제했다.
- 사용자 계좌에서 돈을 뺐다.
- 근데 결제처리 과정에서 뭔가 문제가 생겨서 결제는 안됐네...? 다시 입금은 해줘야하는데...

이때 트랜잭션이 없으면 개발자가 사용자 계좌에 돈을 다시 입금해주는 쿼리문을 써야한다. 근데 매 변경사항마다 혹시모를 장애를 위해 복구문을 직접 써주는건... 생각만해도 더럽지 않나. 연계된 컬럼이 많고 복잡하면 누락될수도 있고? 그리고 이건 걍 내생각이지만, 되돌리기는 이미 있는 기능들을 거꾸로 실행시키는 개념이라면 복구 코드를 직접 쓰는건 하나의 동작이 더 추가되는 것 같기도 하고.. 복구행위는 결제행위가 아니라 정말 말그대로 장애대응을 위한 기능이니까 다른 종류의 기능이 추가되는느낌이라 지들끼리 막 섞여있으면 유지보수 하기도 어려울 것 같다. 

아무튼 이래서 복구기능이 필요한데, 트랜잭션이 있으면 중간에 에러났을때 자동으로 이전의 상태로 되돌려주니까 개발자 입장에서도 편하고 쿼리문 자체도 깔끔해질 것 같다. 그렇다고 이게 무적이냐? 그건 또 아니다. 네트워크가 필요한 작업이나 커넥션까지 같이 트랜잭션에 묶여버리면 문제가 생겼을때 영향이 DBMS까지 직결되니까 앵간하면 가장 컴팩트한 단위로 묶어주는게 좋다. 


# 잠금
하나의 트랜잭션 혹은 여러개의 트랜잭션에서 작업한 내용을 어디까지 공유할건지 정하는 레벨을 의미한다. 하나의 정보를 여러개의 커넥션에서 수정하려하다보면 레코드 값이 어떻게 바뀔지 예측할 수 없어진다. 이런 상황을 방지하기 위해서 한 시점에는 하나의 커넥션만 값을 변경하게 해줘야 한다. 이를 위해 한 레코드나 테이블에 접근 제한을 걸어주는 것이 잠금이다. (동시성 제어)

MySQL의 잠금은 크게 MySQL 엔진의 잠금과 스토리지 엔진 레벨의 잠금로 나뉘어지는데, 전자는 모든 스토리지 엔진에 영향을 미치고 후자는 개별적으로 동작해서 스토리지 엔진끼리 영향을 미치지 않는다. 

## MySQL 엔진의 잠금
### 글로벌락 
MySQL 서버 전체에 걸리는 락으로 제공하는 잠금중 가장 범위가 큰 잠금이다. 데이터베이스, 테이블 할것없이 전부 잠기는데 한 세션에서 글로벌락을 획득하면 다른 세션에서 SELECT를 제외한 DDL,DML 전부 대기상태로 들어간다. 주로 MyISAM, MEMORY 테이블의 덤프를 뜨는 시점에 데이터가 변하지 않게끔 걸어준다. 걸때는 FLUSH TABLES WITH READ LOCK 구문으로 걸고, 모든 테이블에 락걸고 들어가야해서 이전에 실행중인 작업들이 완료되어야 한다.

### 백업락 
근데 InnoDB 엔진이 기본으로 바뀌게 되면서 트랜잭션을 지원하기 때문에 꼭 모든 데이터 작업을 멈출 필요가 없어졌다. 그래서 이젠 `백업락` 이라는 것을 도입하게 되었다. 특정 세션에서 백업락을 획득하게 되면 일반적인 테이블 데이터 변경은 가능하고, 대신 다음 변경만 막힌다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

이를 통해 데이터를 백업하는 레플리카 서버에서 백업하는 도중 DDL 명령이 실행되어도 백업을 처음부터 다시 하는게 아니라 복제를 일시중지하는 방향으로 바뀌었다. 

### 테이블락
테이블단위로 설정되는 잠금이다. 명시적으로는 `LOCK TABLES 테이블 이름` 으로 걸고 `UNLOCK TABLES`으로 푼다. (많이 쓰지는 않는다고 한다.)
묵시적으로는 MyISAM이나 MEMORY 테이블의 데이터를 변경할 때 걸린다. 변경이 끝나면 자동으로 해제된다. InnoDB는 스토리지 엔진 차원에서 레코드 단위로 거니까 DML일때는 안걸고 DDL 일때만 건다.

### 네임드락
`GET LOCK()` 함수를 통해서 임의의 문자열에 대해 잠금을 설정한다. 데이터베이스 객체가 대상이 아닌 사용자 지정 문자열에 대해 거는 잠금이다. 여러 클라이언트가 상호 동기화를 해야할때, 복잡한 요건으로 레코드를 변경하는 트랜잭션에서 사용하기 좋다. 이를테면 배치를 돌리는데 한번에 많은 쿼리를 날리면 데드락 걸릴수도 있으니까 동일한 데이터를 변경하거나 참조하는 프로그램끼리 묶어서 네임드락을 걸고 쿼리를 돌리는 경우들이 있다. 8.0버전부터는 중첩해서 걸수도 있게 됐다. 

### 메타데이터락
데이터베이스 객체(테이블, 뷰)의 이름이나 구조를 변경할때 획득하는 잠금이다. 보통 관련된 쿼리를 날릴때 자동으로 획득하고, 원본과 변경사항에 둘다 잠금을 동시에 걸어서 아주 잠깐동안 발생할 수 있는 Not found 에러를 방지할 수 있다.

## 스토리지 엔진 레벨의 잠금
MyISAM 엔진과 달리 레코드 기반의 잠금방식을 지원한다.

### 레코드락
레코드 자체만을 잠근다. 다른 DBMS와 동일한 역할을 하지만 인덱스 레코드에 잠금을 건다는게 차이점이다. 따로 잡아준 인덱스가 없어도 내부에 자동으로 클러스터인덱스(PK)를 생성하기때문에 InnoDB를 쓰면 걸 수 있다. 

### 갭락 & 넥스트 키락
레코드 자체가 아닌 레코드와 인접한 레코드 사이의 간격을 잠금으로써 새로운 레코드가 생기는걸 제어한다. 넥스트 키락은 레코드락과 갭락을 합쳐놓은건데  주로 바이너리 로그로 레플리카 서버에 데이터를 백업할때 소스서버랑 레플리카 서버내의 데이터를 일치시키기 위한 락이다.

### 자동 증가 락
자동 증가를 위한 AUTO_INCREMENT라는 컬럼 속성이 있다. 이 옵션이 달려있는 상태에서 사용자가 동시에 여러 레코드를 등록하면 저장순서대로 값을 올려줘야한다. 이때 순서대로 증가시키기 위해서 AUTO_INCREMENT 락을 걸어주고 높여준다. 트랜잭션이랑 관계없이 따로 작동되는 락이고 INSERT, REPLACE문이 시작될때 걸렸다가 끝나면 해제된다. 

### 인덱스와 잠금
앞서말했듯 InnoDB는 레코드락 걸때 인덱스에 건다. 따라서 변경되어야 할 레코드를 찾기 위해선 검색한 인덱스의 레코드를 모두 락을 걸어야 한다. 뭔말이냐 하면.. employee 테이블에  first_name이 georgi 인 사람이 300명, last_name이 klassen이라는 사람이 1명이라고 치자. 이때 `update employee SET hire_date=NOW() WHERE first_name = 'georgi' and last_name = 'klassen'` 쿼리문을 실행하면 인덱스 잡힌 first_name 내의 300명 레코드 인덱스에 죄다 락을 건다. 레전드... 인덱스가 없으면 풀테이블 스캔이 잡혀서 테이블 전체 레코드에 락이 걸리게 되는데... 더더욱 암담하다. 

### 레코드 수준의 잠금 확인 및 해제 
잠금 단위가 작다보니 레코드에 잠금 걸린채로 방치되는 경우도 왕왕있다. 5.1버전 이후부터는 잠금에 대한 정보와 대기걸린 정보를 조회할 수 있게 되었다. 강제로 풀려면 KILL 명령을 통해 프로세스나 스레드를 강제 종료해주자.

# MySQL의 격리수준
트랜잭션 격리수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 할건지 말건지를 정하는 것이다. 크게 레벨은 다음과 같이 나뉜다.

- READ UNCOMMITED
- READ COMMITED
- REPEATABLE READ
- SERIALIZABLE

위에서 아래로 갈수록 동시처리 성능이 떨어지고, 데이터간의 격리정도가 높아진다.
트랜잭션 레벨마다 발생할 수 있는 현상들로는 다음과 같이 3가지로 나뉜다.

- DIRTY READ
어떤 트랜잭션의 작업이 완료되지 않아도 다른 트랜잭션에서 변경을 가한걸 볼 수 있는 현상이다. 
- NON-REPEATABLE READ
한 트랜잭션에서 동일한 쿼리문을 날렸을때 동일한 결과가 보장되지 않고 경우에 따라 결과값이 다를 수 있는 현상이다. 
- PHANTOM READ
다른 트랜잭션에서 수행한 변경작업때문에 레코드가 보였다 안보였다 하는 현상이다.

예시는 뒤에 격리수준 설명하면서 같이 하겠다. 

## READ UNCOMMITED
각 트랜잭션에서의 변경내용이 COMMIT 여부와 관계없이 다른 트랜잭션들에서 보이는 격릭수준이다. 위에서 말한 현상들 중 DIRTY READ가 발생한다. 커밋된 데이터가 아닌데도 볼 수 있다 보니 한 트랜잭션에서 변경하다가 롤백해도 다른 트랜잭션에서는 이전의 데이터를 통해 요청을 처리할 수 있다는 문제점이 있다. 정합성에 문제가 많다보니 해당 격리수준은 걍 격리를 안한걸로 치부된다...

## READ COMMITED
오라클 DBMS에서 기본으로 사용되는 격리수준이다. 어떤 트랜잭션에서 데이터를 변경하고 COMMIT하면 그제서야 다른 트랜잭션에서 조회할 수 있다. 방금전에 말한 DIRTY READ는 발생하지 않지만 얘도 정합성 문제가 있긴하다.

- a transaction이 레코드 1번 조회 및 변경
- b transaction이 레코드 1번 조회
- a transaction이 COMMIT
- b transaction이 레코드 1번 조회

이런 경우에는 b transaction이 똑같은 구문을 실행시켰을때 결과값이 다르다. 이런 부정합은 결과값이 어떻게 나올지 정확히 예측하기가 어렵다. 그게 뭔 문제가 있는데? 싶을 수 있지만 만약 동일한 데이터를 여러번 읽으며 변경하는 작업이 금전과 연결되어 있다면...? 문제가 될 수 있다. 

## REPEATABLE READ
InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준이다. 롤백에 대비해서 InnoDB내에 언두로그에 이전 데이터를 백업해두고 실제 레코드 값을 변경한다. 한 데이터에 대해 여러가지 버전을 가지고있는거니 MVCC 개념도 같이 들어가있는거라고 볼 수 있다. 아무튼 REPEATABLE READ는 언두영역에 백업되어있는 이전 데이터에서 쿼리에 대한 결과값을 가져오므로 동일한 트랜잭션 내에서 동일한 결과값을 보장할 수 있다. 

사실 READ COMMITED도 언두영역에서 데이터를 읽어오지만, REPEATABLE READ는 이보다 훨씬 전버전의 데이터를 읽을 수 있다. 어떻게 하냐면... 트랜잭션마다 고유번호가 있는데, 주기적으로 삭제할때 실행중인 트랜잭션보다 이전 트랜잭션 번호를 가진 언두영역의 데이터는 보존하여 그 데이터까지 보게한다. 그러다보니 트랜잭션이 제때 종료되지 않으면 언두영역이 무한정 커지게 되어서 성능이슈가 생길 수 있다. 

해당 레벨에서도 다음과 같은 상황에 부정합이 발생할 수 있다.

- a transaction이 select for update -> 결과 == 1
- b transaction이 insert + commit
- a transaction이 select for update -> 결과 == 2

select 쿼리결과가 다른게 보일텐데, 이렇게 다른 트랜잭션에서 수행한 변경작업에 의해 레코드가 보였다 안보였다 하는 PHANTOM READ가 발생할 수 있다.(NON-REPEATABLE READ랑 헷갈릴 수 있는데 걔는 원래 있던 행의 값이 달라지는거고 얘는 새로운 행이 생긴다는 차이가 있다.) 언두영역에 락을 못걸어서 바로 변경된 값을 가져오다보니 생기는 현상인데 InnoDB는 넥스트 키락을 쓰다보니 발생하지 않는다. 

## SERIALIZABLE
가장 빡센 격리수준이다. 다른 격리수준과 다르게 읽기작업에도 읽기잠금을 획득해야하며 읽기잠금이 걸려있는 레코드는 쓰기도 못해서 변경도 못한다. 그냥 한 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션이 접근할 길이 없어서 대기를 겁나 탄다. 그러다보니 동시처리 성능이 왕왕 떨어진다. 
